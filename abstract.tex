\begin{abstract}
% * Summary of the _entire_ report.
% * Must be 150-300 words
% * Puts your work in context, how it was carried out and what its major
%   successes/conclusions were
%    - Not a contents list
%    - Don't use acronyms unless well-understood
% * Must be able to stand entirely on its own

% * Add further sentences as required (as word count permits) first to results and conclusions and then to methodology â€“ in that order.


% === [ Keywords ] ===
%
%    * Decompilation
%
%    * Composition
%    * Decompilation pipeline
%    * Stages
%    * Language-agnostic
%
%    * LLVM IR
%    * Control flow primitives
%    * Subgraph isomorphism search
%    * Control flow analysis
%    * Recover / reconstruct
%    * Basic block

% --- [ Background and purpose ] -----------------------------------------------

% * What you set out to do and why
% * Why is this interesting?

% 66 words.

Decompilation or reverse compilation is the process of translating low-level machine-readable code into high-level human-readable code. The problem is non-trivial due to the amount of information lost during compilation, but it can be divided into several smaller problems which may be solved independently. This report explores the feasability of composing a decompilation pipeline from independent components, and the potential of exposing those components to the end-user.

% --- [ Methodology ] ----------------------------------------------------------

% * Design

% 62 words.

The components of the decompilation pipeline are conceptually grouped into three modules. The front-end translates a source language (e.g. x86 assembler) into LLVM IR; a platform-independent low-level intermediate representation. The middle-end structures the LLVM IR by identifying high-level control flow primitives (e.g. pre-test loops, 2-way conditionals). Finally, the back-end translates the structured LLVM IR into a high-level target programming language (e.g. Go).

% The control flow analysis component of the decompiler pipeline utilizes subgraph isomorphism search algorithms to identify and reconstruct high-level control flow primitives from LLVM IR.

% The control flow analysis operates directly on graphs and is not dependent on either LLVM IR or

% --- [ Results ] --------------------------------------------------------------

% * What you found

The decompilation pipeline has been proven capable of recovering nested pre-test and post-test loops (e.g. \texttt{while}, \texttt{do-while}), and 1-way and 2-way conditionals (e.g. \texttt{if}, \texttt{if-else}) from LLVM IR. Each stage of the decompilation pipeline is extensible.

A post-processing stage deals with language-specific features

Each stage of the pipeline is extensible.

Each stage of the decompilation pipeline is easily extensible

The decompiler pipeline has proven easily extensible and flexible. It is capable of recovering nested pre-test loops, 2-way conditionals,

% --- [ Conclusion ] -----------------------------------------------------------

% * Future work
% * (recommendations)

% 96 words.

There exists huge potential for future development. Investigate adding further post-processing stages to make the Go output more idiomatic; e.g. the \texttt{grind} tool by Russ Cox moves variable declarations closer to their usage. Finish developing the LLVM IR library to replace the C++ bindings with a pure Go implementation; consider \texttt{llgo} a potential future user. Validate the language-agnostic aspects of the design by implementing components in other languages; e.g. data flow analysis in Haskell. Verify that the middle-end handles heavy decompilation tasks (i.e. control flow analysis, data flow analysis) by implementing additional back-ends (e.g. Python output).

\end{abstract}
