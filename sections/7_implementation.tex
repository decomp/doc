% === [ Implementation ] =======================================================

% <howto>
% * Write the implementation chapter plot heavy (as a novel)
%    - Problem/task
%    - What happened?
%    - How was is solved?
%
% * If the artifact isn't capable of doing everything that was wanted.
%     - Describe problems and reflect on how those problems where solved.
%
% * NOT screenshot (should go in appendix)
%
% * Process of development.
%
% * These are the descitions I made and why.
% * There are interesting problems and here is how I went about solving them.
% * Not just what, but why you did something. What my choices were and why I
%   choose the specific one.
%
% * In the course of the development some changes were made to the design.
% * In the process of doing the implementation, this was the initial design, and
%   these changes had to be made.
%
% Supervisor:
%    - What was this for, why did you do that?

% * Captivative reading
%    - Make the reading captivating; e.g. Dan Brown. And then X, and then Y.
%    - And then I had a problem, and what did I do about it; which lead to these Z.


\section{Implementation}
\label{sec:implementation}

% TODO: Add? Formal IR
% * No Formal Grammar for LLVM IR
% * Look for other people who has done work in this field
% 	- Reed Koter (MIPS), https://code.google.com/p/llvm-assembly-language-formal-specification/
% * Collaborate on the Formal Grammar.

% TODO: Note from Janka: The Implementation section should be strictly related to the software itself.

% TODO: Brainstorm about which sections are actually relevant and how they should be structured.

% TODO: Mention the following trivias:
%    - Identify unused tokens (hash and backspace) in the C++ code base and submit a patch which was commited to remove these. (http://reviews.llvm.org/D7248)
%    - Discuss API design with members of the open source community.
%    - Ask experienced LLVM developers of insight into possible inconsistencies with LLVM IR. Some highlighted inconsistent behaviour and some were intended behaviour. (LLVM-dev mailing list)

% Hints for Computer System Design (1983) - Butler Lampson
%    "Handle normal and worst case seperately"

foo

% --- [ Language Considerations ] ----------------------------------------------

% <howto>
% * choice of programming language(s) (implementation)

\subsection{Language Considerations}

As stated by H. Mayer there are no perfect programming languages; the right tool for the job. As described in section \ref{sec:design} this project seeks to explore the potential of a compositional approach to decompilation, and the language chosen reflects this aspect.

\begin{quote}
	\textit{``No programming language is perfect. There is not even a single best language; there are only languages well suited or perhaps poorly suited for particular purposes. Understanding the problem and associated programming requirements is necessary for choosing the language best suited for the solution.''} - H. Mayer, 1989 \cite{no_perfect_lang_quote}
\end{quote}

% TODO: Clarify the benefits and drawbacks of using Go over C++ which would be the obvious choice for LLVM IR heavy projects. Choosing not to use C++ validates the language-agnostic aspects of the design.
% - Compilation speed. ll2dot takes > 1.5m whereas a regular Go program takes < 1s.

% TODO: Mention software composition.

% TODO: Add and tie in to the pragmatic aspects of Go?
%    * tooling?
%       - "go get" can locate all dependencies.
%       - compilation time is linear rather than exponential with regards to dependencies.
%    * automation?
%    * IMPORTANT: Production quality AST library for Go which is in use by godoc, gofmt, ...

% TODO: Reformulate to fit the section better. Move the pragmatic aspects to the end and add text discussing the production quality AST? Remove the "to make effective use ..." intro. State the requirements of the language clearly, and describe how Go vs. C++ (which would be the obvious choice because of LLVM interaction) lives up to them.

foo

Making effective use of a programming language requires more than simply learning its syntax and key features. With a reasonable understanding of the underlying design decisions behind a programming language and the historic factors which drove its development one may infer the governing principles and key beliefs of its developers. These principles and beliefs influence every aspect of the software development process; they determine how programs are structured and how problems are solved. One of the primary driving forces behind the development of the Go programming language is pragmatism, the idea of which was captured in the following quote by Samuel Tesla shortly after Go was released in 2009:

\begin{quote}
	\textit{``Go is not meant to innovate programming theory. It's meant to innovate programming practice.''} - Samuel Tesla, Dec 2009 \cite{pragmatic}
\end{quote}

In 2012 Rob Pike (one of the Go language inventors) gave a talk titled \textit{``Less is exponentially more''} which included a personal description of the historic events leading up to the inception of Go. The starting point of the language was C, not C++, which Go aimed to simplify further by removing cruft. This stands in direct contrast to the direction of C++ which gains more features with each passing release. The \textit{less is more} mindset is deeply rooted in the mentality of Go developers and there is a strong emphasis on the use of composition to solve problems.

\begin{quote}
	\itshape
	``If C++ and Java are about type hierarchies and the taxonomy of types, Go is about composition.

	Doug McIlroy, the eventual inventor of Unix pipes, wrote in 1964 (!):

	\begin{quote}
		We should have some ways of coupling programs like garden hose--screw in another segment when it becomes necessary to massage data in another way. This is the way of IO also.
	\end{quote}

	That is the way of Go also. Go takes that idea and pushes it very far. It is a language of composition and coupling.''
	\normalfont
	- Rob Pike, 2012 \cite{less_is_more}
\end{quote}

Every aspect of Go development embodies the UNIX philosophy (see figure \ref{fig:unix_philosophy}) which comes as no surprise since Ken Thompson (one of the original inventors of UNIX) is part of the core Go team.

\begin{figure}[htbp]
	\begin{center}
		\begin{quote}
			\textit{``Write programs that do one thing and do it well. Write programs to work together.''} \cite{art_of_unix}
		\end{quote}
		\caption{The UNIX philosophy.}
		\label{fig:unix_philosophy}
	\end{center}
\end{figure}

% --- [ LLVM IR Library ] ------------------------------------------------------

\subsection{LLVM IR Library}

% TODO: <note> incorporate inconsistencies: ref llvm_inconsistencies.txt


foo

% --- [ Control Flow Graph Generation Tool ] -----------------------------------

\subsection{Control Flow Graph Generation Tool}

foo

% --- [ Subgraph Isomorphism Search Algorithm ] --------------------------------

\subsection{Subgraph Isomorphism Search Algorithm}

Implementing the subgraph isomorphism search algorithm was without doubt the most difficult endeavour of the entire project. It took roughly five iterations of implementing, evaluating and rethinking the algorithm to find an approach which felt right and another two iterations to develop a working implementation which passed all the test cases.

foo

% TODO: Incorporate notes from iso_algorithm_notes.txt.

% --- [ Control Flow Analysis Tool ] -------------------------------------------

\subsection{Control Flow Analysis Tool}

foo

% --- [ Decompiler Back-end Tool ] ---------------------------------------------

\subsection{Decompiler Back-end Tool}

foo

% --- [ Documentation ] --------------------------------------------------------

\subsection{Documentation}

% TODO: Add example use cases (perhaps also covering related projects such as McSema)?

A set of source code analysis tools are used to automate the generation and presentation of documentation. The main benefit of this approach is that only one version of the documentation has to be maintained and it is kept within the source code, thus preventing it from falling out of sync with the implementation. UNIX manual pages are generated for command line tools using \texttt{mango} \cite{mango}, which locates the relevant comments and command line flag definitions in the source code. Library documentation is presented using \texttt{godoc} \cite{godoc} (a tool similar to \texttt{doxygen}), and may be accessed through a web or command line interface.

The GoDoc.org server hosts an instance of \texttt{godoc} which presents the documentation of publicly available source code repositories. An online version of the documentation has been made available for each artefact using this service.

\begin{itemize}
	\item Library for interacting with LLVM IR (\textit{work in progress}) \\ \url{https://godoc.org/github.com/mewlang/llvm}
	\item LLVM IR Control Flow Graph generation tool \\ \url{https://godoc.org/github.com/mewrev/ll2dot}
	\item Subgraph isomorphism search algorithms for reconstructing high-level control flow primitives and related tools \\ \url{https://godoc.org/github.com/mewrev/graphs}
	\item Decompiler back-end tool (\textit{proof of concept}) \\ \url{https://godoc.org/github.com/mewrev/ll2go}
\end{itemize}
