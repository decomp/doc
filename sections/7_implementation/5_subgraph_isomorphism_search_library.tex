% --- [ Subgraph Isomorphism Search Library ] ----------------------------------

\subsection{Subgraph Isomorphism Search Library}
\label{sec:impl_subgraph_isomorphism_search_library}

Implementing the subgraph isomorphism search algorithm was without doubt the most difficult endeavour of the entire project. It took roughly five iterations of implementing, evaluating and rethinking the algorithm to find an approach which felt right and another two iterations to develop a working implementation which passed all the test cases.

As mentioned in section \ref{sec:ver_performance}, an early throwaway prototype provided a partial implementation of the subgraph isomorphism algorithm proposed by Ullman. The prototype was intended to provide insight into the subgraph isomorphism problem domain, and was eventually discarded.

The second throwaway prototype was specifically designed to exploit known properties of CFG (e.g. connected graphs with a single entry node) to limit the search space. Focusing on connected graphs drastically simplified the general problem of subgraph isomorphism search, and enabled algorithms which traverse the graph from a given start node to identify subgraph isomorphisms. The second prototype has many issues (e.g. non-deterministic, unable to handle graph cycles), but provided valuable insight into how a subgraph isomorphism search algorithm may be designed when focusing on connected graphs.

In contrast to its predecessor, the third prototype separated subgraph isomorphism candidate discovery from candidate validation logic. A subgraph isomorphism candidate is a potential isomorphism of a subgraph in a graph, which provides a mapping from subgraph node names to graph node names. Should the source and the destination nodes of each directed edge in the subgraph translate through the candidate node mapping to corresponding nodes (with a directed edge from the source to the destination node) in the graph, and should furthermore each node in the subgraph have the same number of directed edges as the nodes of the candidate (with a few caveats regarding entry and exit nodes), then the candidate is considered a valid isomorphism of the subgraph in the graph.

As described in section \ref{sec:design_control_flow_analysis} and further evaluated in section \ref{sec:eval_control_flow_analysis_library_essential_requirements}, subgraphs have a single-entry/single-exit invariant to simplify control flow analysis. This allows identified subgraphs to be replaced with single nodes, which inherit the predecessors of the subgraph entry node and successors of the subgraph exit node. For this reason, the candidate validation logic disregards the directed edges from predecessors of subgraph entry nodes and the directed edges to successors of subgraph exit nodes, when validating subgraph isomorphism candidates; which should clarify the aforementioned caveats of the preceding paragraph.

The third prototype was still incomplete (mainly with regards to candidate discovery) when discarded, but the separation of candidate discovery and candidate validation logic has had a large influence on its succeeding prototypes.

Similar to the third prototype, the fourth throwaway prototype separated candidate discovery from candidate validation. In addition, it introduced the concept of treating candidate node mappings as equations which may be solved, or at least partially solved. The candidate node mappings were extended from one-to-one node mappings (one subgraph node name maps to exactly one graph node name) to node pair mappings, which represent one-to-many node mappings (one subgraph node name maps to zero or more graph node names). The candidate discovery logic was extended to record all potential candidate nodes for a given subgraph node, when traversing the graph in search of candidates. A simple equation solver was implemented which was capable of identifying unique node pair mappings and propagate this information to successively simplify equations until they are either solved or require other methods for solving; an example of which is presented in figure \ref{fig:unique_equation_solver}.

\begin{figure}[htbp]
	\centering
	\begin{subfigure}[t]{0.30\textwidth}
		\lstinputlisting[language=go, style=go, breaklines=false, numbers=none]{inc/7_impl/unique_equation_1.json}
		\caption{Step 1.}
	\end{subfigure}
	\enskip
	\begin{subfigure}[t]{0.23\textwidth}
		\lstinputlisting[language=go, style=go, breaklines=false, numbers=none]{inc/7_impl/unique_equation_2.json}
		\caption{Step 2.}
	\end{subfigure}
	\enskip
	\begin{subfigure}[t]{0.17\textwidth}
		\lstinputlisting[language=go, style=go, breaklines=false, numbers=none]{inc/7_impl/unique_equation_3.json}
		\caption{Step 3.}
	\end{subfigure}
	\caption{In step 1, the unique node pair mapping between the subgraph node name \textit{C} and the graph node name \textit{Z} is identified, and the remaining node pair mappings are simplified by removing \textit{Z} from their candidate nodes. Similarly, in step 2, the unique node pair mapping between \textit{B} and \textit{Y} is identified; thus simplifying the equation. In step 3, the unique node pair mapping between \textit{A} and \textit{X} is identified, and the equation is thereby solved.}
	\label{fig:unique_equation_solver}
\end{figure}


%
%Take 3 (https://github.com/decomp/graphs/commit/95e65fefd0b6ab30dfa08aae1a2fa229249ee3e4) (https://github.com/decomp/graphs/commit/454417df3d83704dbad2b108be99dd8b06aea938):
%	Learn from take 2, separating candidate discovery and candidate validation logic is the way to go. Start thinking of the node pair mapping as an equation which may be solved. Only capable of solving simple equations by locating unique node pair mappings and successivly simplifying the equation until it is either solved or unsolved.
%
%		"A": {"A", "B", "C"}
%		"B": {"B", "C"}
%		"C": {"C"}
%
%		First "C": "C" gives the new equation:
%
%		"A": {"A", "B"}
%		"B": {"B"}
%
%		"B": "B" gives the new equation:
%
%		"A": {"A"}
%
%		"A": "A" solves the equation.
%
%	The algorithm would however fail to solve the following equation:
%
%		"A": {"A", "B"}
%		"B": {"A", "B"}
%
%Take 4 (https://github.com/decomp/graphs/commit/c56cf8e563d2c0882f3c182cd50499eda3f3a61b) (https://github.com/decomp/graphs/commit/e45339b2a48a2416f80ff1a2df74cbe1c4816708) (https://github.com/decomp/graphs/commit/f2e9a232c2b3bd3caf605f5388745f6a1a2e5c35)
%	Duplicate an equation and try different candidate mappings recursively to find a solution. Try to solve the various equations concurrently and relay the solution ("valid or not valid") through the use of channels.
%
%Take 5 (https://github.com/decomp/graphs/commit/b51a48682cdfb4d2816ee2afbe4167325b3fbd64) (https://github.com/decomp/graphs/commit/fad6516071997fa3b208240f1c2de8008a65ad51) (https://github.com/decomp/graphs/commit/b15e97172cb2c941341238122b4048537bb41e30) (https://github.com/decomp/graphs/commit/b67ce12e6f328be6174efc0a7881e056340a22e1) (https://github.com/decomp/graphs/commit/5261b8ae8db0ffc6dab8f81b09980e919307e7c4) (https://github.com/decomp/graphs/commit/8ebffc397dda60653ccdb81e761274c165b337ac)
%	The approach feels right. Start testing and factoring working implementations into a "known good" file!
%
%Take 6 (https://github.com/decomp/graphs/commit/a820a006a70affaf786d0ac598dffa4f3fa05059) (https://github.com/decomp/graphs/commit/c7e58dafc22b29ec6bee8a1c3b7a97cd28b317e3)
%	Reimplement equation solver. New version no longer concurrent. Greatly simplified. The new version passes the previous test cases!
%
%Final solution (https://github.com/decomp/graphs/pull/1)
%	The final implementation of the subgraph isomorphism search algorithm was a cleaned and heavily tested version of take 6. It was developed in the "isobug" branch and merged once stable into the "master" branch. The pull request tracking this work is located at "Fix implementation of subgraph isomorphism search". (https://github.com/decomp/graphs/pull/1)

foo

% # Set-backs and how they were dealt with...
%
% Isomorphism returns false as soon as it hits the end of any branch in the tree. It incorrectly assumes that all graphs have only one exit node. This is why iso handles list.dot correctly for the upper parts of the graph.

% * throw away prototyping -> find a solution that feels right -> try to find corner cases that doesn't work (for-loops) -> write test cases from the bottom up (testing independent behaviour and then testing functionality which depends on the now known to be correct functionality) -> factor code into known good until all code has been tested
