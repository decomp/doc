% --- [ Subgraph Isomorphism Search Library ] ----------------------------------

\subsection{Subgraph Isomorphism Search Library}
\label{sec:impl_subgraph_isomorphism_search_library}

Implementing the subgraph isomorphism search algorithm was without doubt the most difficult endeavour of the entire project. It took roughly five iterations of implementing, evaluating and rethinking the algorithm to find an approach which felt right and another two iterations to develop a working implementation which passed all the test cases.

As mentioned in section \ref{sec:ver_performance}, an early throwaway prototype provided a partial implementation of the subgraph isomorphism algorithm proposed by Ullman. The prototype was intended to provide insight into the subgraph isomorphism problem domain, and was eventually discarded.

The second throwaway prototype was specifically designed to exploit known properties of CFG (e.g. connected graphs with a single entry node) to limit the search space. Focusing on connected graphs drastically simplified the general problem of subgraph isomorphism search, and enabled algorithms which traverse the graph from a given start node to identify subgraph isomorphisms. The second prototype has many issues (e.g. non-deterministic, unable to handle graph cycles), but provided valuable insight into how a subgraph isomorphism search algorithm may be designed when focusing on connected graphs.

In contrast to its predecessor, the third prototype separated subgraph isomorphism candidate discovery from candidate validation logic. A subgraph isomorphism candidate is a potential subgraph isomorphism, which provides a mapping from subgraph node names to graph node names. Should the source and the destination nodes of each directed edge in the subgraph translate through the candidate node mapping to corresponding nodes in the graph, and should furthermore each node in the subgraph have the same number of directed edges as the nodes of the candidate (with a few caveats regarding entry and exit nodes), then the candidate is considered a valid isomorphism of the subgraph in the graph. The third prototype was still incomplete (mainly with regards to candidate discovery), but its separation of candidate discovery and candidate validation logic has been of huge influence to its succeeding prototypes.

Similar to the third prototype, the fourth throwaway prototype separated candidate discovery from candidate validation. In addition, it started treating candidate node mappings as equations which may be solved, or at least partially solved. Each node mapping (one-to-one) was extended into a node pair mapping (one-to-many), which recorded every

 In addition, it extended the concept of candidate node mappings (one-to-one node mappings) into equations of node pair mappings (one-to-many node mappings), which may be either solved or partially solved.

it started treating candidate node mappings as equations which may be solved, or at least partially solved.

%
%Take 3 (https://github.com/decomp/graphs/commit/95e65fefd0b6ab30dfa08aae1a2fa229249ee3e4) (https://github.com/decomp/graphs/commit/454417df3d83704dbad2b108be99dd8b06aea938):
%	Learn from take 2, separating candidate discovery and candidate validation logic is the way to go. Start thinking of the node pair mapping as an equation which may be solved. Only capable of solving simple equations by locating unique node pair mappings and successivly simplifying the equation until it is either solved or unsolved.
%
%		"A": {"A", "B", "C"}
%		"B": {"B", "C"}
%		"C": {"C"}
%
%		First "C": "C" gives the new equation:
%
%		"A": {"A", "B"}
%		"B": {"B"}
%
%		"B": "B" gives the new equation:
%
%		"A": {"A"}
%
%		"A": "A" solves the equation.
%
%	The algorithm would however fail to solve the following equation:
%
%		"A": {"A", "B"}
%		"B": {"A", "B"}
%
%Take 4 (https://github.com/decomp/graphs/commit/c56cf8e563d2c0882f3c182cd50499eda3f3a61b) (https://github.com/decomp/graphs/commit/e45339b2a48a2416f80ff1a2df74cbe1c4816708) (https://github.com/decomp/graphs/commit/f2e9a232c2b3bd3caf605f5388745f6a1a2e5c35)
%	Duplicate an equation and try different candidate mappings recursively to find a solution. Try to solve the various equations concurrently and relay the solution ("valid or not valid") through the use of channels.
%
%Take 5 (https://github.com/decomp/graphs/commit/b51a48682cdfb4d2816ee2afbe4167325b3fbd64) (https://github.com/decomp/graphs/commit/fad6516071997fa3b208240f1c2de8008a65ad51) (https://github.com/decomp/graphs/commit/b15e97172cb2c941341238122b4048537bb41e30) (https://github.com/decomp/graphs/commit/b67ce12e6f328be6174efc0a7881e056340a22e1) (https://github.com/decomp/graphs/commit/5261b8ae8db0ffc6dab8f81b09980e919307e7c4) (https://github.com/decomp/graphs/commit/8ebffc397dda60653ccdb81e761274c165b337ac)
%	The approach feels right. Start testing and factoring working implementations into a "known good" file!
%
%Take 6 (https://github.com/decomp/graphs/commit/a820a006a70affaf786d0ac598dffa4f3fa05059) (https://github.com/decomp/graphs/commit/c7e58dafc22b29ec6bee8a1c3b7a97cd28b317e3)
%	Reimplement equation solver. New version no longer concurrent. Greatly simplified. The new version passes the previous test cases!
%
%Final solution (https://github.com/decomp/graphs/pull/1)
%	The final implementation of the subgraph isomorphism search algorithm was a cleaned and heavily tested version of take 6. It was developed in the "isobug" branch and merged once stable into the "master" branch. The pull request tracking this work is located at "Fix implementation of subgraph isomorphism search". (https://github.com/decomp/graphs/pull/1)

foo

% # Set-backs and how they were dealt with...
%
% Isomorphism returns false as soon as it hits the end of any branch in the tree. It incorrectly assumes that all graphs have only one exit node. This is why iso handles list.dot correctly for the upper parts of the graph.

% * throw away prototyping -> find a solution that feels right -> try to find corner cases that doesn't work (for-loops) -> write test cases from the bottom up (testing independent behaviour and then testing functionality which depends on the now known to be correct functionality) -> factor code into known good until all code has been tested
