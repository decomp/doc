% --- [ Go Bindings for LLVM ] -------------------------------------------------

\subsection{Go Bindings for LLVM}
\label{sec:go_bindings_for_llvm}

In the beginning of February a decision was taken to defer the development of the LLVM IR library (see section \ref{sec:llvm_ir_library}) and make use of the Go bindings for LLVM instead. This decision was motivated by time constraints and has had both positive and negative implications for the project. Most importantly, it became possible to rapidly implement working prototypes of the artefacts once the focus shifted from utility library development to core component development. Furthermore, when LLVM 3.6 was released in the end of February, the components automatically gained support for the new LLVM IR metadata syntax which was introduced in this release.

Several components (e.g. \texttt{ll2dot}, \texttt{ll2go}) use the Go bindings for LLVM\footnote{Go bindings for LLVM: \url{https://godoc.org/llvm.org/llvm/bindings/go/llvm}} to interact with LLVM IR assembly. The API of the Go bindings mimics that of the C bindings, which feels awkward as it bypasses the safety of the type system. A fundamental concept of the API is the notion of a \textit{value}, which represents a computed value that may be used as an operand of other values. This recursive description captures the semantics of instructions and constants. The API provides a unified \texttt{Value} type, which defines 145 methods for interacting with the underlying value types. It is the callers responsibility to only invoke the subset of methods actually implemented by the underlying type. In practise this approach results in fragile applications which may crash during runtime; with assertions such as \textit{``cast<Ty>() argument of incompatible type!''} when invoking the \texttt{Opcode} method instead of the \texttt{InstructionOpcode} method on an instruction value. The former method may only be invoked on constants, which uses a subset of the instruction opcodes for constant expressions. A more sound approach would solve these issues by refining the \texttt{Value} interface be the \textit{intersect} rather than the \textit{union} of all methods implemented on the underlying value types.

The control flow analysis stage of the decompilation pipeline requires access to the names of unnamed basic blocks, but these names are not accessible from the API of the Go bindings for LLVM as they are generated on the fly by the assembly printer. To work around this issue, the assembly printer of LLVM 3.6 was patched to always print the generated names of unnamed basic blocks (see appendix \ref{app:unnamed_patch}). Once patched, the debug facilities of LLVM could be utilized to print the assembly to temporary files, which may be parsed to gain access to the names of unnamed basic blocks. This solution works, but it is considered highly temporary and may cause security implications (as further described in section \ref{sec:security_assessment}). When the pure Go LLVM IR library (see section \ref{sec:llvm_ir_library}) reaches maturity it will replace the use of the Go bindings for LLVM, thus mitigating the aforementioned issues.
