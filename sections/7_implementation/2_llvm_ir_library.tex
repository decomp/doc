% --- [ LLVM IR Library ] ------------------------------------------------------

\subsection{LLVM IR Library}
\label{sec:impl_llvm_ir_library}

Early on in the project it was believed that the control flow analysis stage would operate on CFGs that were tightly coupled with an in-memory representation of LLVM IR. This motivated the search for a LLVM IR library with a carefully considered API and set of data structures (objective \ref{itm:obj_ir_library}). While there existed a library which provided Go bindings for LLVM, the API of this library felt awkward to use and was too heavily influenced by the underlying C and C++ libraries; as further described in section \ref{sec:impl_go_bindings_for_llvm}. The interaction with the LLVM IR library would influence the design and implementation of the decompilation components in critical ways. For this reason it was decided that a set of pure Go libraries would be implemented for interacting with LLVM IR, even if it would require a considerable amount of work.

% TODO: Update footnote link name; e.g. llgo requirements.

The LLVM IR libraries were intentially developed as reusable components for compilers, decompilers and other semantic analysis tools. To assess the requirements of LLVM-based compilers, a public discussion was held with the developers of the \texttt{llgo} compiler, who clarified its specific requirements\footnote{\texttt{llgo} requirements: \url{https://github.com/go-llvm/llvm/issues/40}}. Fredrik Ehnbom, who is one of the \texttt{llgo} developers, has remained involved during the development of the LLVM IR libraries, and has participated in API discussions.

The first component to be implemented was the LLVM IR lexer, which tokenize LLVM IR assembly. In addition to the LLVM IR language specification, the implementation of the reference lexer in LLVM was reviewed to establish a full listing of the valid tokens in LLVM IR. This review uncovered two tokens which were defined but never used in the code base of LLVM. In collaboration with members of the LLVM community, a patch was commited to the LLVM code base which removed these tokens\footnote{Remove unused tokens from AsmParser: \url{http://reviews.llvm.org/D7248}}.

%The design of the LLVM IR lexer has been hugely influenced by a talk given by Rob Pike in 2011, titled \textit{``Lexical Scanning in Go''} \cite{lexical_scanning_in_go}. In this talk, Pike introduces the notion of a state function which is a function that returns a state function. The state of the lexer is represented by the active state function, which may transition into another stage by returning the corresponding state function.

%For instance, when \texttt{lexLineComment} is active, the context of the lexer is known to be a line comment. Any character is valid within line comments, except new lines which terminate the token and

%The active state function represents the state of the lexer (e.g. if the \texttt{lexLineComment} function is active )

%State functions are able to record the state of the lexer (e.g. the \texttt{lexLineComment} state function ), and signal the transition from one state to another by returning the appropriate state function based on the current character of the input. For instance, if the active state function is lexing the

%a state function which lexes numeric constants may be returned if the current character is a digit

%, and a state function which lexes string literals may be returned if the current character is a double quote. Implementing a lexer in this way was straight forward and resulted in a well structured library.




% TODO: Mention Fredrik Ehnbom
% benchmark delta: -18.27%. \footnote{Use binary search for keyword lexing: \url{https://github.com/llir/llvm/pull/11}}

% TODO: Mention that the LLVM IR library is incomplete. Only the lexer is complete, support for constants and types is partial. Parsing support is being implemented.

% TODO: incorporate notes from llvm_inconsistencies.txt

% ### lexer problem ###
%
% * 2015-01-08
% * Backtrack to last valid token.
% 0.1e-foo
%      ^
% * No separator required between tokens. No newline required between TopLevelEntities

% ### lexer solution ###
%
% Use candidate tokens and parse each possible kind separately. The longest token "wins" and is emitted. Afterwards the current position is treated accordingly before the next token is being lexed. Rethink line, col to facilitate this work. 1am idea in bed.

% ### problem
% ## inconsistencies
%
%     valid: 1 br
%     valid: 1br
%
% kind: 258 (APSInt) []
% kind: 228 (kw_br) []
% kind: 258 (APSInt) []
% kind: 228 (kw_br) []
% kind:   0 (Eof) []
%
%     valid: br 1
%     invalid: br1
%
% kind: 228 (kw_br) []
% kind: 258 (APSInt) []
% kind:   1 (Error) []
% kind:   1 (Error) []
% kind: 258 (APSInt) []
% kind:   0 (Eof) []
%
% ### solution
%
% Solution: define a consistent behaviour, e.g. the next token is the longest sequence of characters that form a valid token.

%* Potential time solver (inspiration from Flare)
%One of everything approach. Skip named types for now. Allow heavy computation in the error case. Make normal case simple. (IsConst function on values doing recursive checks and to be used in constat expression input validation after switching to Value)

% ### set backs and solutions ###
%After months of working with implementing LLVM IR support for Go, it started to dawn on me that the task was way more time consuming than anticipated. Break-through idea at 9.45 in the morning on the 8th of Feb having just arrived back in Portsmouth after a few weeks in Brussels and FOSDEM. All the structual analysis algorithms should operate on DOT-graphs. This would make it truly language agnostic! Future work would complete the LLVM IR support and make translate the CFG into a DOT-graph, using basic block names as node names and specifying branches as edges and conditional branches as labeled edges.

%As is often the case, the constraints forced new ways of thinking, which gave rise to a radically different design. ref TED talk.

%* By using DOT files for the CFGs instead of relying on the in-memory representations it was possible to switch from the pure Go lib to the C++ binding without compromising the envisioned design. The entire solution is very modular and easy to adapt and adjust.

% ### motivation
%The cheer size of LLVM IR was at times discouraging and the project time constrains forced the implementation of subsets within every aspect of the language. LLVM IR is a RISC like assembly language which seems to have started out as a simple, quite minimalistic and in some aspects platform independent low level language. As time went by and as the project rose in popularity more and more developers joined the project. In 2014 more than one thousand commits were submitted to llvm code base each month. Keeping these changes concistent and the overall system simple is a massive challenge. It is very easy for new contributers to gain write access.

%Several features seems stitched on without taking into consideration the large picture. This becomes apparent by the large number of keywords in the language, the inconsistent choice of prefix for local names and module types. It is amazing what LLVM is capable of, but it is unfortunate that these capabilities have made the core language so cluttered.

%It was very tempting to switch to REIL as this language is minimal, concistent and clean. The adoptation of the language in the open source community is however low and there have been no public news announcements since Google bought the company. Also, and maybe more importantly the REIL language lacks the notion of a basic block so for the control flow analysis a new abstraction would have to be built anyways; the output of which may have been a new language, thus defeating the core objective of a language-agnostic solution building on formally defined IRs.

A formal grammar of the LLVM IR language would have facilitate the implementation of the LLVM IR libraries. As no such grammar had been officially endorsed, other sources were cross-referenced to learn about the low-level details of the language, such as its token set and details regarding the type system. This work uncovered a number of potential inconsistencies between the language reference, the implementation, and official blog posts. After discussing these issues with more experienced LLVM developers on the LLVM-dev mailing list, it could be concluded that some issues highlighted inconsistent behaviours while others were working as intended.

foo
