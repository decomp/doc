% --- [ LLVM IR Library ] ------------------------------------------------------

\subsection{LLVM IR Library}
\label{sec:impl_llvm_ir_library}

% TODO: Check https://github.com/llir/llvm/issues/8 for a meta issue of test-cases.

% A formal grammar of the LLVM IR language would have facilitate the implementation of the LLVM IR library. As no such grammar has been officially endorsed, other sources were cross-referenced to learn about the low-level details of the language, such as its token set and details regarding the type system. This work uncovered a number of inconsistencies between the language reference, the implementation, and official blog posts.

% TODO: Add? Formal IR
% * No Formal Grammar for LLVM IR
% * Look for other people who has done work in this field
%    - Reed Koter (MIPS), https://code.google.com/p/llvm-assembly-language-formal-specification/
% * Collaborate on the Formal Grammar.


% TODO: Clarify how state functions work.

% TODO: Move "LLVM IR" design related text to a utility library subsection of design? A section could be created for the "DOT library" as well.

design: discuss the API with members of the open source community (llvm issue requirements, Fredrik and awk).

The design of the LLVM IR lexer has been hugely influenced by a talk given by Rob Pike in 2011, titled \textit{``Lexical Scanning in Go''} \cite{lexical_scanning_in_go}. In this talk, Pike introduces the notion of a state function which is a function that returns a state function. The state of the lexer is represented by the active state function, which may transition into another stage by returning the corresponding state function.

For instance, when \texttt{lexLineComment} is active, the context of the lexer is known to be a line comment. Any character is valid within line comments, except new lines which terminate the token and

The active state function represents the state of the lexer (e.g. if the \texttt{lexLineComment} function is active )

State functions are able to record the state of the lexer (e.g. the \texttt{lexLineComment} state function ), and signal the transition from one state to another by returning the appropriate state function based on the current character of the input. For instance, if the active state function is lexing the

a state function which lexes numeric constants may be returned if the current character is a digit

, and a state function which lexes string literals may be returned if the current character is a double quote. Implementing a lexer in this way was straight forward and resulted in a well structured library.

In addition to the LLVM IR language specification, the implementation of the reference lexer in LLVM was reviewed to establish a full listing of the valid tokens in LLVM IR. This review uncovered two tokens which were defined but never used in the code base of LLVM. In collaboration with members of the LLVM community, a patch was commited to the LLVM code base which removed these tokens\footnote{Remove unused tokens from AsmParser: \url{http://reviews.llvm.org/D7248}}.

% TODO: Mention that the LLVM IR library is incomplete. Only the lexer is complete, support for constants and types is partial. Parsing support is being implemented.

% TODO: incorporate notes from llvm_inconsistencies.txt

% TODO: Add design notes
%    - The LLVM IR libraries are developed as reusable components for compilers, decompilers, and other semantic analysis tools. They aim to support generic semantic analysis applications, while satisfying the explicit requirements [1] of the third party llgo compiler.
%
% [1]: https://github.com/go-llvm/llvm/issues/40


% ### lexer problem ###
%
% * 2015-01-08
% * Backtrack to last valid token.
% 0.1e-foo
%      ^
% * No separator required between tokens. No newline required between TopLevelEntities

% ### lexer solution ###
%
% Use candidate tokens and parse each possible kind separately. The longest token "wins" and is emitted. Afterwards the current position is treated accordingly before the next token is being lexed. Rethink line, col to facilitate this work. 1am idea in bed.


% ### problem
% ## inconsistencies
%
%     valid: 1 br
%     valid: 1br
%
% kind: 258 (APSInt) []
% kind: 228 (kw_br) []
% kind: 258 (APSInt) []
% kind: 228 (kw_br) []
% kind:   0 (Eof) []
%
%     valid: br 1
%     invalid: br1
%
% kind: 228 (kw_br) []
% kind: 258 (APSInt) []
% kind:   1 (Error) []
% kind:   1 (Error) []
% kind: 258 (APSInt) []
% kind:   0 (Eof) []
%
% ### solution
%
% Solution: define a consistent behaviour, e.g. the next token is the longest sequence of characters that form a valid token.




* Potential time solver (inspiration from Flare)
One of everything approach. Skip named types for now. Allow heavy computation in the error case. Make normal case simple. (IsConst function on values doing recursive checks and to be used in constat expression input validation after switching to Value)


% ### set backs and solutions ###
After months of working with implementing LLVM IR support for Go, it started to dawn on me that the task was way more time consuming than anticipated. Break-through idea at 9.45 in the morning on the 8th of Feb having just arrived back in Portsmouth after a few weeks in Brussels and FOSDEM. All the structual analysis algorithms should operate on DOT-graphs. This would make it truly language agnostic! Future work would complete the LLVM IR support and make translate the CFG into a DOT-graph, using basic block names as node names and specifying branches as edges and conditional branches as labeled edges.

As is often the case, the constraints forced new ways of thinking, which gave rise to a radically different design. ref TED talk.

* By using DOT files for the CFGs instead of relying on the in-memory representations it was possible to switch from the pure Go lib to the C++ binding without compromising the envisioned design. The entire solution is very modular and easy to adapt and adjust.


% ### motivation
The cheer size of LLVM IR was at times discouraging and the project time constrains forced the implementation of subsets within every aspect of the language. LLVM IR is a RISC like assembly language which seems to have started out as a simple, quite minimalistic and in some aspects platform independent low level language. As time went by and as the project rose in popularity more and more developers joined the project. In 2014 more than one thousand commits were submitted to llvm code base each month. Keeping these changes concistent and the overall system simple is a massive challenge. It is very easy for new contributers to gain write access.

Several features seems stitched on without taking into consideration the large picture. This becomes apparent by the large number of keywords in the language, the inconsistent choice of prefix for local names and module types. It is amazing what LLVM is capable of, but it is unfortunate that these capabilities have made the core language so cluttered.

It was very tempting to switch to REIL as this language is minimal, concistent and clean. The adoptation of the language in the open source community is however low and there have been no public news announcements since Google bought the company. Also, and maybe more importantly the REIL language lacks the notion of a basic block so for the control flow analysis a new abstraction would have to be built anyways; the output of which may have been a new language, thus defeating the core objective of a language-agnostic solution building on formally defined IRs.


foo
