% --- [ Control Flow Analysis Library ] ----------------------------------------

\subsection{Control Flow Analysis Library}
\label{sec:eval_control_flow_analysis_library}

In total five essential (\textbf{R9}, \textbf{R10}, \textbf{R11}, \textbf{R12} and \textbf{R13}), two important (\textbf{R14} and \textbf{R15}), two desirable (\textbf{R16} and \textbf{R17}), and two future (\textbf{R18} and \textbf{R19}) requirements were identified for the control flow analysis library (see section \ref{sec:req_control_flow_analysis_library}). The current implementation of the control flow library satisfies six out of nine requirements (not counting future requirements), and fails to satisfy one essential, one important, and one desirable requirement; as summarized in table \ref{tbl:eval_summary_of_control_flow_analysis_library}. Section \ref{sec:eval_control_flow_analysis_library_essential_requirements}, \ref{sec:eval_control_flow_analysis_library_important_requirements} and \ref{sec:eval_control_flow_analysis_library_desirable_requirements} provides a detailed evaluation of the essential, important and desirable requirements, respectively.

% TODO: Create green, red and grey background for the yes, no and N/A rows respectively. Use different levels of green/red for MUST, SHOULD, COULD. WON'T is always grey.

% TODO: Apply a similar colour scheme to the tables in the requirements section for the sake of familiarity? Using different shades of grey/blue? Probably not.

% TODO: Use tick boxes instead of yes/no? Probably not.

\begin{table}[htbp]
	\begin{center}
		\begin{tabular}{|l|l|l|l|}
			\hline
			Satisfied? & Req. & Priority & Description \\
			\hline
			Yes & \textbf{R9} & MUST & Support analysis of reducible graphs \\
			Yes & \textbf{R10} & MUST & Recover pre-test loops (e.g. \texttt{for}, \texttt{while}) \\
			No & \textbf{R11} & MUST & Recover infinite loops (e.g. \texttt{while(TRUE)}) \\
			Yes & \textbf{R12} & MUST & Recover 1-way conditionals (e.g. \texttt{if}) \\
			Yes & \textbf{R13} & MUST & Recover 2-way conditionals (e.g. \texttt{if-else}) \\
			Yes & \textbf{R14} & SHOULD & Recover post-test loops (e.g. \texttt{do-while}) \\
			No & \textbf{R15} & SHOULD & Recover n-way conditionals (e.g. \texttt{switch}) \\
			No & \textbf{R16} & COULD & Recover multi-exit loops \\
			Yes & \textbf{R17} & COULD & Recover nested loops \\
			N/A & \textbf{R18} & WON'T & Support analysis of irreducible graphs \\
			N/A & \textbf{R19} & WON'T & Recover compound boolean expressions \\
			\hline
		\end{tabular}
	\end{center}
	\caption{A summary of the evaluation against requirements of the control flow analysis library.}
	\label{tbl:eval_summary_of_control_flow_analysis_library}
\end{table}

% ~~~ [ Essential Requirements ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\subsubsection{Essential Requirements}
\label{sec:eval_control_flow_analysis_library_essential_requirements}

% * R9 - Support analysis of reducible graphs

The current implementation of the control flow analysis library supports analysis of reducible graphs (\textbf{R9}), as demonstrated by the step-by-step analysis of a reducible CFG in appendix \ref{app:control_flow_analysis_example}.

% * R10 - Recover pre-test loops
% * R12 - Recover 1-way conditionals

The successful recovery of pre-test loops (\textbf{R10}) and 1-way conditionals (\textbf{R12}) is demonstrated in four steps, using components which depend on the control flow analysis library. Firstly, the \texttt{ll2dot} tool (see section \ref{sec:design_control_flow_graph_generation}) is used to generate an unstructured CFG for each function of an LLVM IR assmebly file; as demonstrated in appendix \ref{app:control_flow_graph_generation_example}. Secondly, the \texttt{restructure} tool (see section \ref{sec:design_control_flow_analysis}) analyzes the unstructured CFG of an LLVM IR assembly function to produce a structured CFG; as demonstrated in appendix \ref{app:restructure_example}. Thirdly, the \texttt{ll2go} tool (see section \ref{sec:design_code_generation}) uses the high-level control flow information of the structured CFG to decompile the LLVM IR function into unpolished Go code; as demonstrated in appendix \ref{app:code_generation_example}. Lastly, the \texttt{go-post} tool applies source code transformations to the unpolished Go code in order to improve its quality; as demonstrated in appendix \ref{app:post-processing_example}. The final Go output, which is presented on the right side of figure \ref{fig:example1_comparison} in appendix \ref{app:post-processing_example}, contains both a \texttt{for}-loop and an \texttt{if}-statement, thus proving that pre-test loops and 1-way conditionals may be recovered.

% * R13 - Recover 2-way conditionals

The successful decompilation of 2-way conditionals (\textbf{R13}) is demonstrated in appendix \ref{app:decompilation_of_nested_primitives}, which provides a contrived example that implicitly uses the same decompilation steps as described above. The final Go output, which is presented on the right side of figure \ref{fig:nested_comparison} in appendix \ref{app:decompilation_of_nested_primitives}, contains an \texttt{if-else} statement, thus proving that 2-way conditionals may be recovered.

% * R11 - Recover infinite loops

foo

% TODO: Add
% * The current implementation of the control flow analysis library enforces an invariant on the graph representation of high-level control flow primitives; they must have a single entry and a single exit node. This invariant simplifies the implementation
% * requires an a single entry and a single exit node
% * single-entry, single-exit an invariant of the

% ~~~ [ Important Requirements ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\subsubsection{Important Requirements}
\label{sec:eval_control_flow_analysis_library_important_requirements}

% * R14 - Recover post-test loops

The successful decompilation of post-test loops (\textbf{R14}) is demonstrated in appendix \ref{app:decompilation_of_post-test_loops}, which provides a contrived example that implicitly uses the same decompilation steps as described above. The final Go output, which is presented on the right side of figure \ref{fig:post-test_comparison} in appendix \ref{app:decompilation_of_post-test_loops}, contains an infinite \texttt{for}-loop with a conditional break statement as the last statement of the loop body (Go does not have native support for \texttt{do-while} loops, so the semantics of the a post-test loop have been imitated using the available control flow primitives), thus proving that post-test loops may be recovered.

% * R15 - Recover n-way conditionals

foo

% ~~~ [ Desirable Requirements ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\subsubsection{Desirable Requirements}
\label{sec:eval_control_flow_analysis_library_desirable_requirements}

% * R16 - Recover multi-exit loops

foo

% * R17 - Recover nested loops

The successful decompilation of nested loops (\textbf{R17}) is demonstrated in appendix \ref{app:decompilation_of_nested_primitives}, which provides a contrived example that implicitly uses the same decompilation steps as described above. The final Go output, which is presented on the right side of figure \ref{fig:nested_comparison} in appendix \ref{app:decompilation_of_nested_primitives}, contains nested \texttt{for}-loops (one inner loop and one outer loop), thus proving that nested loops may be recovered.
