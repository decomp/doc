% ~~~ [ Essential Requirements ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\subsubsection{Essential Requirements}
\label{sec:eval_control_flow_analysis_tool_essential_requirements}

% * R20 - Identify high-level control flow primitives in LLVM IR

In collaboration, the \texttt{ll2dot} and \texttt{restructure} tools are capable of identifying high-level control flow primitives in LLVM IR (\textbf{R20}). Firstly, the \texttt{ll2dot} tool generates CFGs (in the DOT file format) for each function of the LLVM IR, as described in section \ref{sec:design_control_flow_graph_generation} and demonstrated in appendix \ref{app:control_flow_graph_generation_example}. Secondly, the \texttt{restructure} tool structures the CFGs to recover high-level control-flow primitives from the underlying LLVM IR, as described in section \ref{sec:design_control_flow_analysis} and demonstrated in appendix \ref{app:restructure_example}.

% * R21 - Support language-agnostic interaction with other components

% TODO: Add lang ref links.

The components of the decompilation pipeline support language-agnostic interaction with other components (\textbf{R21}), as they only communicate using well-defined input and output; specifically LLVM IR\footnote{LLVM Language Reference Manual: \url{http://llvm.org/docs/LangRef.html}}, DOT\footnote{foo}, JSON\footnote{foo} and Go\footnote{The Go Programming Language Specification: \url{http://golang.org/ref/spec}} input and output. The interaction between the components of the decompilation pipeline is demonstrated in four steps, when decompilation LLVM IR to Go. Firstly, the control flow graph generation component (see section \ref{sec:design_control_flow_graph_generation}) parses LLVM IR assembly to produce an unstructured CFG (in the DOT file format); as demonstrated in appendix \ref{app:control_flow_graph_generation_example}. Secondly, the control flow analysis component (see section \ref{sec:design_control_flow_analysis}) analyzes the unstructured CFG (in the DOT file format) to produce a structured CFG (in JSON format); as demonstrated in appendix \ref{app:restructure_example}. Thirdly, the code generation component (see section \ref{sec:design_code_generation}) decompiles the structured LLVM IR assembly into unpolished Go code; as demonstrated in appendix \ref{app:code_generation_example}. Lastly, the post-processing tool (see section \ref{sec:design_post-processing}) improves the quality of the unpolished Go code, by applying a set of source code transformations; as demonstrated in appendix \ref{app:post-processing_example}.
