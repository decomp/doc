% ~~~ [ MC-Semantics ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\subsubsection{MC-Semantics}

% TODO: Find the correct and succinct term for the "control flow recover" component.

MC-Semantic conceptually consists of two components which separate concerns related to the disassembly stage (see section \ref{sec:lit_review_disassembly}) from those of the intermediate code generation stage (see section \ref{sec:lit_review_intermediate_code_generation}). The control flow recovery component analyzes binary files and disassembles their machine instructions to produce CFGs

communicate using well-defined input and output. Firstly, the control flow recovery component analyzes binary files, disassembles their native code, and produces a CFG

parses binary files, disassembles native code  and disassembles   which separate concerns related to the disassembly stage (see section \ref{sec:lit_review_disassembly}) from the ones related to the intermediate code generation stage (see section \ref{sec:lit_review_intermediate_code_generation}).

defines two distinct components which separate concerns related to the disassembly stage (see section \ref{sec:lit_review_disassembly}) from the ones related to the intermediate code generation stage (see section \ref{sec:lit_review_intermediate_code_generation}). These components interact using well-defined input and output (e.g. Google Protocol Buffers), which has enabled two independent implementations of the control flow recover component, which deals with the disassembly stage. Furthermore, these two implementations are written in different programming languages (i.e. Python and C++), which validates the language-agnostic aspects of the design.

% TODO: Add illustration of the interaction between the components of the MC-Semantics project.

An illustration of the interaction between the components of the MC-Semantics project is presented in figure \ref{foo}.

Dagger and MC-Semantics uses a structure to keep track of all registers and passes a pointer to this structure as an argument to each function. Reads from and writes to registers are made using loads and stores.

With proper use-def chains the *input* and *output* of a function could be made apparent, removing the need to pass the entire structure to each function. Registers could be passed by value as parameters which would facilitate several optimization passes.

% TODO: Evaluate and highlight key differences between Dagger, Fracture and McSema.
% Dagger and Fracture rely on TableGen for instruction semantics, McSema does not.

% TODO: Research; https://github.com/trailofbits/mcsema

% TODO: Re-watch the youtube talk again.

% bin_descend and IDA python script of MC-Semantics -> Google Protocol Buffer -> cfg_to_bc -> LLVM IR

foo \cite{mcsema}

% TODO: Verify supported formats.
* MC-Sema support:

PE (x86)
COFF (x86)
ELF (x86)
