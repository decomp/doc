% ~~~ [ Disassembly ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\subsubsection{Disassembly}
\label{sec:lit_review_disassembly}

The disassembly phase (referred to as the \textit{syntactic analysis phase} by C. Cifuentes) is responsible for decoding the raw machine instructions of the executable segments into assembly. The computer architecture dictates how the assembly instructions and their associated operands are encoded. Generally CISC architectures (e.g. x86) use variable length instruction encoding (e.g. instructions occupy between 1 and 15 bytes in x86) and allow memory addressing modes for most instructions (e.g. arithmetic instructions may refer to memory locations in x86) \cite{x86_manual}. In contract, RISC architectures (e.g. ARM) generally use fixed-length instruction encoding (e.g. instructions always occupy 4 bytes in AArch64) and only allow memory access through load-store instructions (e.g. arithmetic instructions may only refer to registers or immediate values in ARM) \cite{arm_manual}.

One of the main problems of the disassembly phase is how to separate code from data. In the Von Neumann architecture the same memory unit may contain both code and data. Furthermore, the data stored in a given memory location may be interpreted as code by one part of the program, and as data by another part. In contrast, the Harvard architecture uses separate memory units for code and data \cite{von_neumann_vs_harvard}. Since the use of the Von Neumann architecture is wide spread, solving this problem is fundamental for successful disassemblers.

The most basic disassemblers (e.g. \texttt{objdump} and \texttt{ndisasm}) use linear descent when decoding instructions. Linear descent disassemblers decode instructions consecutively from a given entry point, and contain no logic for tracking the flow of execution. This approach may produce incorrect disassembly when code and data are intermixed (e.g. switch tables stored in executable segments); as illustrated in figure \ref{fig:comparison_between_linear_and_recursive_descent}. More advanced disassemblers (e.g. IDA) often use recursive descent when decoding instructions, to mitigate this issue.

Recursive descent disassemblers track the flow of execution and decode instructions from a set of locations known to be reachable from a given entry point. The set of reachable locations is initially populated with the entry points of the binary (e.g. the \texttt{start} or \texttt{main} function of executables and the \texttt{DllMain} function of shared libraries). To disassemble programs, the recursive descent algorithm will recursively pop a location from the reachable set, decode its corresponding instruction, and add new reachable locations from the decoded instruction to the reachable set, until the reachable set is empty. When decoding non-branching instructions (e.g. \texttt{add}, \texttt{xor}), the immediately succeeding instruction is known to be reachable (as it will be executed after the non-branching instruction) and its location is therefore added to the reachable set. Similarly, when decoding branching instructions (e.g. \texttt{br}, \texttt{ret}), each target branch (e.g. the conditional branch and the default branch of conditional branching instructions) is known to be reachable and therefore added to the reachable set; unless the instruction has no target branches, as is the case with return instructions. This approach is applied recursively until all paths have reached an end-point, such as a return instruction, and the reachable set is empty. To prevent cycles, the reachable locations are tracked and only added once to the reachable set.

\begin{figure}[htbp]
	\centering
	\begin{subfigure}[t]{0.49\textwidth}
		\lstinputlisting[language=nasm, style=nasm, tabsize=2]{inc/2_lit_review/hello/hello_linear.asm}
		\caption{Disassembly from \texttt{objdump} and \texttt{ndisasm}\protect\footnotemark.}
	\end{subfigure}
	\qquad
	\begin{subfigure}[t]{0.35\textwidth}
		\lstinputlisting[language=nasm, style=nasm, tabsize=2]{inc/2_lit_review/hello/hello_recursive.asm}
		\caption{Disassembly from IDA.}
	\end{subfigure}
	\caption{The disassembly produced by a linear descent parser (left) and a recursive descent parser (right) when analyzing a simple \textit{``hello world''} program that stores the \texttt{hello} string in the executable segment.}
	\label{fig:comparison_between_linear_and_recursive_descent}
\end{figure}
\footnotetext{The Netwide Disassembler: \url{http://www.nasm.us/doc/nasmdoca.html}}

%One problem faced by both linear descent and recursive descent disassemblers is the need for a starting point. Identifying exported entry point symbols (e.g. \texttt{main}, \texttt{start}, \texttt{DllMain}, â€¦) for this purpose works well in practice.

%Another problem for recursive descent disassemblers is indirect branches (e.g. branch to the address stored in a register). In the case of indirect branches, it is impossible to know the branch target only by looking at the individual instructions. One solution is to use symbolic execution, which emulates the processor and executes instructions to give information about the value stored in registers. With this method the target of indirect jumps may be calculated.

% PROBLEM: security, performance, ...?

%There exists several anti-disassembly techniques which are commonly used by malware. One such technique exploits the fact that recursive descent parsers follow both the true and the false branch of conditional branch instructions, as demonstrated in figure \ref{fig:anti-disassembly}. The recursive descent parser cannot parse both the \textit{true} and the \textit{false}-branch of the conditional branch instruction at line 3, because the \textit{true}-branch targets the middle of a \texttt{jmp} instruction.

%The conditional branch instruction at line 3 always takes the true branch, which points to the middle of the \texttt{jmp} instruction decoded when parsing the false branch. The recursive descent parser cannot disassembly both branches and is forced to choose one of them, in this case the \texttt{fake} branch.

%The recursive descent parser fails by using a conditional branch instruction (\texttt{jz}) which always takes the true-branches \texttt{fake+1} which is in the middle of an instruction.

\begin{figure}[htbp]
	\centering
	\begin{subfigure}[t]{0.59\textwidth}
		\lstinputlisting[language=nasm, style=nasm, tabsize=2]{inc/2_lit_review/hello/anti_orig.asm}
		\caption{Original assembly.}
	\end{subfigure}
	\qquad
	\begin{subfigure}[t]{0.34\textwidth}
		\lstinputlisting[language=nasm, style=nasm, tabsize=2]{inc/2_lit_review/hello/anti_fail.asm}
		\caption{Disassembly from IDA.}
	\end{subfigure}
	\caption{The original assembly (left) contains an anti-disassembly trick which causes the recursive descent parser to fail (right).}
	\label{fig:anti-disassembly}
\end{figure}

%The anti-disassembly technique presented in figure \ref{fig:anti-disassembly} may be mitigated using symbolic execution, which could verify that the conditional jump always takes the true branch and therefore allow the instruction to be replaced with an unconditional jump to the target of the true branch. This quickly becomes a game of cat-and-mouse, as the anti-disassembly techniques could be extended to rely on network activity, file contents, or other external sources which would render the symbolic exeuction useless.

%To conclude, the disassembly phase deals with non-trivial problems, some of which are difficult to automate. Advanced disassemblers (such as IDA) therefore provide interactive capabilities and rely on human intuition to solve ambiguities and direct the disassembler out of corner cases.
