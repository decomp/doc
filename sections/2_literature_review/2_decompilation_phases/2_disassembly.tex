% ~~~ [ Disassembly ] ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

\subsubsection{Disassembly}
\label{sec:lit_review_disassembly}

The disassembly phase (referred to as the \textit{syntactic analysis phase} by C. Cifuentes) is responsible for decoding the raw machine instructions of the executable segments into assembly. The computer architecture dictates how the assembly instructions and their associated operands are encoded. Generally CISC architectures (e.g. x86) use variable length instruction encoding (e.g. instructions occupy between 1 and 17 bytes in x86) and allow memory addressing modes for most instructions (e.g. arithmetic instructions may refer to memory locations in x86) \cite{x86_manual}. In contract, RISC architectures (e.g. ARM) generally use fixed-length instruction encoding (e.g. instructions always occupy 4 bytes in AArch64) and only allow memory access through load-store instructions (e.g. arithmetic instructions may only refer to registers or immediate values in ARM) \cite{arm_manual}.

One of the main problems of the disassembly phase is how to separate code from data. In the Von Neumann architecture the same memory unit may contain both code and data. Furthermore, the data stored in a given memory location may be interpreted as code by one part of the program, and as data by another part. In contrast, the Harvard architecture uses separate memory units for code and data \cite{von_neumann_vs_harvard}. Since the use of the Von Neumann architecture is wide spread, solving this problem is fundamental for successful disassemblers.

% TODO: Add switch tables example.

A solution to the problem of separating code from data is to use recursive descent instead of linear descent when parsing assembly instructions.

% TODO: Add description of recursive descent and linear descent.

\begin{figure}[htbp]
	\centering
	\begin{subfigure}[t]{0.49\textwidth}
		\lstinputlisting[language=nasm, style=nasm, tabsize=2]{inc/2_lit_review/hello/hello_linear.asm}
		\caption{Disassembly from \texttt{objdump} and \texttt{ndisasm}\protect\footnotemark.}
	\end{subfigure}
	\qquad
	\begin{subfigure}[t]{0.35\textwidth}
		\lstinputlisting[language=nasm, style=nasm, tabsize=2]{inc/2_lit_review/hello/hello_recursive.asm}
		\caption{Disassembly from IDA.}
	\end{subfigure}
	\caption{The disassembly produced by a linear descent parser (left) and a recursive descent parser (right) when analyzing a simple \textit{``hello world''} program that stores the \texttt{hello} string in the executable segment.}
\end{figure}
\footnotetext{The Netwide Disassembler: \url{http://www.nasm.us/doc/nasmdoca.html}}

One problem faced by both linear descent and recursive descent disassemblers is the need for a starting point. In practice, exported entry point symbols (e.g. \texttt{main}, \texttt{start}, \texttt{DLLMain}, â€¦) works well.

% TODO: Verify that it is called symbolic execution/symbolic execution engine.

Another problem for recursive descent disassemblers is indirect branches (e.g. jump to the address stored in a register). In the case of indirect branches, it is impossible to know the branch target by only looking at the individual instructions. One solution is to use symbolic execution, which emulates the processor and executes instructions to give information about the value stored in registers. With this method the target of indirect jumps may be calculated. There are problems to consider when designing a symbolic execution engine, for instance the impact of cached memory access. See figure \ref{foo} for an example of where cache details matter for the execution flow.

% TODO: Add example where the cache impacts execution flow (pipeline pre-schedules). *addr = 5; jmp addr

% Problems:
% * self-modifying code
% * Architecture-dependent Restrictions
%    Cannot be determined by step-by-step debugging; as the prefetch pipeline
%    would behave differently.
%       mov ax, 0x9090
%       mov [jmpDef], ax
%    jmpDef:
%       jmp codeExecuted
%    codeNotExecuted:
%       foo
%    codeExecuted:
%       bar

Another issue is the use of callbacks, which is common in GUI applications.
% TODO: Solution? Run program and use breakpoints?

There exists several anti-disassembly techniques which are commonly used by malware. One such technique exploits the fact that recursive descent parsers follow both the true and the false branch of conditional branch instructions, as demonstrated in figure \ref{fig:anti-disassembly}.

The recursive descent parser cannot parse both the false and the true-branch of the conditional branch instruction at line 3, because the true branch targets the middle of a \texttt{jmp} instruction.

The conditional branch instruction at line 3 always takes the true branch, which points to the middle of the \texttt{jmp} instruction decoded when parsing the false branch. The recursive descent parser cannot disassembly both branches and is forced to choose one of them, in this case the \texttt{fake} branch.

The recursive descent parser fails by using a conditional branch instruction (\texttt{jz}) which always takes the true-branches \texttt{fake+1} which is in the middle of an instruction.

\begin{figure}[htbp]
	\centering
	\begin{subfigure}[t]{0.59\textwidth}
		\lstinputlisting[language=nasm, style=nasm, tabsize=2]{inc/2_lit_review/hello/anti_orig.asm}
		\caption{Original assembly.}
	\end{subfigure}
	\qquad
	\begin{subfigure}[t]{0.34\textwidth}
		\lstinputlisting[language=nasm, style=nasm, tabsize=2]{inc/2_lit_review/hello/anti_fail.asm}
		\caption{Disassembly from IDA.}
	\end{subfigure}
	\caption{The original assembly (left) contains an anti-disassembly trick which causes the recursive descent parser to fail (right).}
	\label{fig:anti-disassembly}
\end{figure}

The anti-disassembly technique presented in figure \ref{fig:anti-disassembly} may be mitigated using symbolic execution, which could verify that the conditional jump always takes the true branch and therefore allow the instruction to be replaced with an unconditional jump to the target of the true branch. This quickly becomes a game of cat-and-mouse, as the anti-disassembly techniques could be extended to rely on network activity, file contents, or other external sources which would render the symbolic exeuction useless.

To conclude, the disassembly phase deals with non-trivial problems, some of which are difficult to automate. Advanced disassemblers (such as IDA) therefore provide interactive capabilities and rely on human intuition to solve ambiguities and direct the disassembler out of corner cases.

% TODO: Introduce the various approaches and highlight their individual
% strengths and weaknesses.
%
% NAIVE APPROACH: linear descent disassemblers.
% PROBLEM: Highlight problems with linear descent disassemblers.
%    - rodata (e.g. "hello world") and jump tables in code.
%
% SOLUTION: recursive descent disassemblers.
% PROBLEM: Highlight problems with recursive descent disassemblers.
%    - Distinguish between code and data (e.g. find entry points of functions).
%      Not add functions are directly referred to (e.g. callback functions which
%      are commonly used by GUI applications).
%    - Easy to fool.
%       xor eax, eax
%       cmp eax, 0
%       jz foo+1 ; Cannot disassembly both foo and foo+1.
% foo:
%       add eax, 3
%
% SOLUTION: symbolic execution engines.
% PROBLEM: security, performance, ...?
