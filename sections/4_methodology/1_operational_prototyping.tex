% --- [ Operational Prototyping ] ----------------------------------------------

\subsection{Operational Prototyping}

The software artefacts were implemented using two distinct stages. The aim of the first stage was to get a better understanding of the problem domain, to identify suitable data structures, and to arrive at a solid approach for solving the problem. To achieve these objectives, a set of throwaway prototypes (see section~\ref{sec:method_throwaway_prototyping}) were iteratively implemented, discarded and redesigned until the requirements of the artefact were well understood and a mature design had emerged. The aim of the second stage was to develop a production quality software artefact based on the insights gained from the first stage. To achieve this objective, evolutionary prototyping (see section~\ref{sec:method_evolutionary_prototyping}) was used to develop a solid foundation for the software artefact and incrementally extend its capabilities by implementing one feature at the time, starting with the features that were best understood.

This approach is very similar to the operational prototyping methodology, which was proposed by A. Davis in 1992. One important concept in operational prototyping is the notion of a quality baseline, which is implemented using evolutionary prototyping and represents a solid foundation for the software artefact. Throwaway prototypes are implemented on top of the quality baseline for poorly understood parts of the system, to gain further insight into their requirements. The throwaway prototypes are discarded once their part of the system is well-understood, at which point the well-understood parts are carefully reimplemented and incorporated into the evolutionary prototype to establish a new quality baseline~\cite{operational_prototyping}. In summary, throwaway prototyping is used to \textit{identify} good solutions to problems, while evolutionary prototyping is used to \textit{implement} identified solutions.

A major benefit with this approach is that it makes it easy to track the evolution of the design, by referring back to the throwaway prototypes which gave new insight into the problem domain; as demonstrated when tracking the evolution of the subgraph isomorphism search algorithm in section~\ref{sec:impl_subgraph_isomorphism_search_library}. A concrete risk with operational prototyping is that throwaway prototypes may end up in production systems, if not discarded as intended. As mentioned in section~\ref{sec:method_throwaway_prototyping}, the throwaway prototypes enable rapid iteration cycles by ignoring several areas of quality software (e.g. maintainability, efficiency and usability) and should therefore never end up in production systems. The use of revision control systems could help mitigate this risk, as they tracks old versions of the source code which may lower the psychological threshold for removing code (e.g. the code is not permanently removed, and may later be recovered if needed).

% --- [ Subsubsections ] -------------------------------------------------------

\input{sections/4_methodology/1_operational_prototyping/1_throwaway_prototyping}
\input{sections/4_methodology/1_operational_prototyping/2_evolutionary_prototyping}
