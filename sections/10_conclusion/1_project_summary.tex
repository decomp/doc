% --- [ Project Summary ] ------------------------------------------------------

\subsection{Project Summary}

Reverse engineering has fascinated me for quite some time and I have experimented with a variety of tools, ranging from disassemblers and decompilers to debuggers and tracers. Many tools have been outstanding on an individual level and some have featured powerful extensibility through plugin and scripting support. I have never been bothered by the capabilities of these tools, but rather by the workflow they enforce.

The de facto tools for binary analysis are monolithic in nature with regards to the end-user, as they do not expose their individual components. Imagine trying to reuse the control flow analysis of IDA Pro and the Hex-Rays Decompiler to implement control flow aware folding support in an IDE for x86 assembly development (e.g. group and toggle assembly code segments based on their corresponding high-level control flow structures). This idea is not limited by any technical issues; IDA Pro and the Hex-Rays Decompiler have support for recovering high-level control flow primitives from x86 assembly. If the IDE was given access to the control flow analysis component it would be trivial to implement sophisticated folding support for x86 assembly.

Having worked extensively within a UNIX environment, I have grown accustomed to a workflow that allows you to \textit{combine} individual tools in amazing ways; pipe the input from one tool into another which transforms, massages or interprets the data in a specific way to solve a given task. This background has instilled me with a belief that the decompilation workflow could be facilitated by implementing a decompilation pipeline composed of individual and reusable components. Throughout the course of this project several independent components have been implementing, including a control flow graph generation tool which generates control flow graphs (in the DOT file format) from LLVM IR assembly, a control flow analysis tool which identifies high-level control flow primitives in control flow graphs, a code generation tool which translates structured LLVM IR assembly into unpolished Go source code, and a post-processing tool which polishes Go source code to make it more idiomatic.

These components have been combined with open source tools from other projects to form the foundation of a decompilation pipeline, which may translate a variety of source languages into the Go programming language. The decompilation pipeline has been proven capable of recovering nested pre-test and post-test loops (e.g. \texttt{for} and \texttt{do-while} loops), and 1-way and 2-way conditionals (e.g. \texttt{if} and \texttt{if-else} statements) from LLVM IR assembly. While the project has succeeded at implementing a \textit{proof of concept} decompilation pipeline, creating the One True decompilation pipeline has been considered a non-goal \cite{non-goals}. The aim of the project has always been on exploring the feasibility and potential of a decompilation pipeline composed of individual and reusable components which interact through well-defined input and output.

To conclude, the project has succeeded at proving the feasibility of compositional decompilation through the implementation of a \textit{proof of concept} decompilation pipeline which exposes its components to the end-user. The true potential of this approach is still being explored, and section \ref{sec:future_work} details future plans on stress testing the design and exploring innovative uses of the individual components.
