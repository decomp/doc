% --- [ Hex-Rays Decompiler ] --------------------------------------------------

\subsection{Hex-Rays Decompiler}
\label{sec:rel_work_hex-rays_decompiler}

The Interactive Disassembler (IDA) and the Hex-Rays decompiler are the de facto tools used in industry for binary analysis, malware forensics and reverse engineering~\cite{semantics_preserving_structural_analysis}. The interactive capabilities of IDA enables users to guide the disassembler through non-trivial problems (e.g. anti-disassembly techniques used by malware) related to the disassembly phase, some of which have been outlined in section~\ref{sec:lit_review_disassembly}. This approach turns out to be very powerful, as it is facilitated by human ingenuity and problem solving skills.

The Hex-Rays decompiler is implemented on top of IDA as a plugin, which separates concerns related to the disassembly phase from the later decompilation stages. The decompilation process of the Hex-Rays decompiler is divided into several distinct stages. Firstly, the microcode generation stage translates machine instructions into Hex-Rays Microcode, which is a RISC-like IR that is similar to REIL (see section~\ref{sec:lit_review_reil}). Secondly, the optimisation stage removes dead code (e.g. unused conditional flag accesses) from the unoptimised IR. Thirdly, the data flow analysis tracks the input and output registers of functions, to determine their calling conventions. Fourthly, the structural analysis stage analyses the CFGs of functions to produce a control tree containing the recovered high-level control flow primitives. The control flow recovery algorithm of the Hex-Rays decompiler handles irreducible graphs by generating \texttt{goto}-statements, which is similar to the approach taken by C. Cifuentes (see section~\ref{sec:lit_review_control_flow_analysis}). Fifthly, the pseudocode generation stage translates the IR into unpolished pseudocode (in C syntax). Sixthly, the pseudocode transformation stage improves the quality of the unpolished pseudocode by applying source code transformations; e.g. translate \texttt{while}-loops into \texttt{for}-loops by locating the initialisation and post-statements of the loop header. Lastly, the type analysis stage analyses the generated pseudocode to determine and propagate variable types, by building and solving type equations~\cite{hexrays}.

Unlike other decompilers, the type analysis stage is the last stage of the Hex-Rays decompiler. According to the lead developer of Hex-Rays, one benefit with postponing the type analysis stage (which is normally conducted in the middle-end rather than the back-end), is that more information is available to guide the type recovery and enforce rigid constraints on the type equations. A major drawback with this approach is that the type analysis has to be reimplemented for every back-end.
