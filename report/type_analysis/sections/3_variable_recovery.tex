% === [ Variable Recovery ] ====================================================

\section{Variable Recovery}

Variable and typing information is lost during the process of compilation, as local and global variables, function arguments and function parameters are lowered from source code to machine code and mapped onto type-less registers and memory locations. Debug information of binary executables may record this mapping. When debug information is limited or absent however, the source variables have to be recovered from low-level code using variable recovery methods. Since type analysis is based on inference between type typing relations of variables, variable recovery is required for type recovery.

To explain different aspects of variable recovery and type analysis, two running examples are used throughout this paper. The first example (see figure \ref{fig:running_example} of appendix \ref{app:running_example}) details a function \texttt{f} which keeps track of local variables using a base pointer (\texttt{ebp}). The second example (see figure \ref{fig:struct_example} of appendix \ref{app:struct_example}) details a function \texttt{g} which operates on an array of structures, and a function \texttt{h} which operates on a structure pointer. Subsequent in text references to \texttt{f}, \texttt{g} and \texttt{h} correspond to these three functions.

% === [ Subsections ] ==========================================================

\input{sections/3_variable_recovery/1_value_set_analysis}
\input{sections/3_variable_recovery/2_function_signature_recovery}
